"""Some utility functions for the project"""

import sympy
import hashlib

def fiat_shamir(data, p):
    """Hashes data and reduces it modulo p.

    Args:
        data: The data to hash, should be ok to serialize it
              to a string with str().
        p: The prime number to reduce the hash to.

    Returns:
        An integer modulo p.
    """

    serialized_data = str(data).encode('utf-8')
    hasher = hashlib.blake2b(serialized_data)
    digest_bytes = hasher.digest()

    digest_int = int.from_bytes(digest_bytes, 'big')
    return digest_int % p

def find_nth_root(n, p, prime_factors=None):
    """Return a primitive k-th root of unity modulo q so that
       k > n and k is a power of 2. Assumes q is prime.

    Args:
        n: the number of roots of unity to find
        q: the prime modulus
        prime_factors: optionally, a list of prime factors of q-1,
                       where the primes appear as p**n,
                       not as p multiple times.

    Returns:
        A tuple w, k, where w the k-th root of unity
    """
    if prime_factors is None:
        prime_factors = []
    k = 2
    while k < p:
        while (k < n) or (p-1) % k != 0:
            k *= 2
            if k > p:
                raise ValueError("could not find suitable k")
        g = 1
        while g < p:
            g += 1
            assert pow(g, (p-1), p) == 1    # assume q is prime
            for d in (prime_factors):
                if pow(g, (p-1) // d, p) == 1:
                    break
            else:
                w = pow(g, (p-1) // k, p)
                if pow(w, k, p) == 1 and pow(w, k // 2, p) != 1:
                    return w, k
        k *= 2

    raise ValueError("could not find suitable k")


def is_quadratic_residue(k, p):
    """Determine if k is a quadratic residue modulo p.

    Args:
        k: the element to check
        p: the prime modulus

    Returns:
        True if k is a quadratic residue modulo p, False otherwise
    """
    legendre_symbol = pow(k, (p-1) // 2, p)
    if legendre_symbol == p - 1:
        return False
    return legendre_symbol == 1

def get_cosets_constants(w, H, p):
    """Find two integers k1, k2 so that k1*w and k2*w
       generate cosets of H

    Args:
        w: a primitive root of unity modulo p
        H: the group generated by w
        p: the prime modulus

    Returns:
        The tuple k1, k2
    """
    k1 = 2
    is_w_residue = is_quadratic_residue(w,p)

    while is_quadratic_residue(k1, p) == is_w_residue:
        k1 += 1
    k1H = [k1 * x % p for x in H]
    k2 = k1 + 1
    while is_quadratic_residue(k2, p) == is_w_residue or k2 in k1H:
        k2 += 1

    return k1, k2


def interpolate(xs, ys, p):
    """
    Interpolate a polynomial in a finite field F_p given points xs and values ys).
    xs and ys can be of different lengths, will ignore extra points/values.
    xs shuold be unique.

    Args:
        xs: List of x-coordinates of points.
        ys: List of corresponding y-coordinates of points.
        p: Prime defining the finite field F_p.

    Returns:
        A list of coefficients of the interpolated polynomial, starting
        from the highest degree.
    """
    # check xs are unique
    assert len(xs) == len(set(xs))

    length = min(len(xs), len(ys))
    xs = xs[:length]

    x = sympy.symbols('x')
    domain = sympy.FF(p)
    poly = sympy.Poly(0, x, domain=domain)

    for i, xi in enumerate(xs):
        # Compute Lagrange basis polynomial for x_i
        Li = sympy.Poly(1, x, domain=domain)
        for j, xj in enumerate(xs):
            if i != j:
                quot, rem = sympy.Poly(x - xj, x, domain=domain).div(
                    sympy.Poly(xi - xj, x, domain=domain))
                assert rem == 0
                Li *= quot

        poly += sympy.Poly(ys[i] * Li, x, domain=domain)

    return [x % p for x in poly.all_coeffs()]
