"""Some utility functions for the project"""

import sympy

def find_nth_root(n, q, prime_factors=None):
    """Return a primitive k-th root of unity modulo q so that
       k > n and k is a power of 2. Assumes q is prime.

    Args:
        n: the number of roots of unity to find
        q: the prime modulus
        prime_factors: optionally, a list of prime factors of q-1,
                       where the primes appear as p**n,
                       not as p multiple times.

    Returns:
        A tuple w, k, where w the k-th root of unity
    """
    if prime_factors is None:
        prime_factors = []
    k = 2
    while k < q:
        while (k < n) or (q-1) % k != 0:
            k *= 2
            if k > q:
                raise ValueError("could not find suitable k")
        g = 1
        while g < q:
            g += 1
            assert pow(g, (q-1), q) == 1    # assume q is prime
            for d in (prime_factors):
                if pow(g, (q-1) // d, q) == 1:
                    break
            else:
                w = pow(g, (q-1) // k, q)
                if pow(w, k, q) == 1 and pow(w, k // 2, q) != 1:
                    return w, k
        k *= 2

    raise ValueError("could not find suitable k")


def is_quadratic_residue(k, p):
    """Determine if k is a quadratic residue modulo p.

    Args:
        k: the element to check
        p: the prime modulus

    Returns:
        True if k is a quadratic residue modulo p, False otherwise
    """
    legendre_symbol = pow(k, (p-1) // 2, p)
    if legendre_symbol == p - 1:
        return False
    return legendre_symbol == 1

def get_cosets_constants(w, H, p):
    """Find two integers k1, k2 so that k1*w and k2*w
       generate cosets of H

    Args:
        w: a primitive root of unity modulo p
        H: the group generated by w
        p: the prime modulus

    Returns:
        The tuple k1, k2
    """
    k1 = 2
    is_w_residue = is_quadratic_residue(w,p)

    while is_quadratic_residue(k1, p) == is_w_residue:
        k1 += 1
    k1H = [k1 * x % p for x in H]
    k2 = k1 + 1
    while is_quadratic_residue(k2, p) == is_w_residue or k2 in k1H:
        k2 += 1

    return k1, k2


def interpolate(xs, ys, p):
    """
    Interpolate a polynomial in a finite field F_p given points (xs, ys)

    Args:
        xs: List of x-coordinates of points (must be distinct).
        ys: List of corresponding y-coordinates of points.
        p: Prime defining the finite field F_p.

    Returns:
        A list of coefficients of the interpolated polynomial, starting
        from the highest degree.
    """
    x = sympy.symbols('x')
    domain = sympy.FF(p)
    poly = sympy.Poly(0, x, domain=domain)

    for i, xi in enumerate(xs):
        # Compute Lagrange basis polynomial for x_i
        Li = sympy.Poly(1, x, domain=domain)
        for j, xj in enumerate(xs):
            if i != j:
                quot, rem = sympy.Poly(x - xj, x, domain=domain).div(xi - xj)
                assert rem == 0
                Li *= quot

        poly += ys[i] * Li

    return [x % p for x in poly.all_coeffs()]
